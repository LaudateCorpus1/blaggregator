from django.conf import settings
from django.test import TestCase
from django.test.utils import override_settings
import feedparser

from home.models import Post, User, Hacker
from .utils import create_posts

N_MAX = settings.MAX_FEED_ENTRIES


@override_settings(AUTHENTICATION_BACKENDS=('django.contrib.auth.backends.ModelBackend', 'home.token_auth.TokenAuthBackend'))
class FeedsViewTestCase(TestCase):

    def setUp(self):
        self.setup_test_user()

    def tearDown(self):
        self.clear_db()

    def test_should_enforce_authentication(self):
        response = self.client.get('/atom.xml')
        self.assertEqual(response.status_code, 404)

        response = self.client.get('/atom.xml', data={'token': ''})
        self.assertEqual(response.status_code, 404)

    def test_should_enforce_token(self):
        self.login()
        response = self.client.get('/new/')
        self.assertEqual(response.status_code, 200)

        response = self.client.get('/atom.xml')
        self.assertEqual(response.status_code, 404)

        response = self.client.get('/atom.xml', data={'token': ''})
        self.assertEqual(response.status_code, 404)

    def test_feed_with_no_posts(self):
        self.verify_feed_generation(0)

    def test_feed_with_posts_less_than_max_feed_size(self):
        self.verify_feed_generation(N_MAX - 1)

    def test_feed_with_posts_more_than_max_feed_size(self):
        self.verify_feed_generation(N_MAX * 5)

    # Helper methods ####

    def login(self):
        """Login as test user."""
        self.client.login(username=self.username, password=self.password)

    def clear_db(self):
        User.objects.all().delete()

    def parse_feed(self, content):
        """Parse feed content and return entries."""
        # FIXME: Would it be a good idea to use feedergrabber?
        return feedparser.parse(content)

    def setup_test_user(self):
        self.username = self.password = 'test'
        self.user = User.objects.create_user(self.username)
        self.user.set_password(self.password)
        self.user.save()
        self.hacker = Hacker.objects.create(user_id=self.user.id)

    def get_included_excluded_posts(self, posts, entries):
        """Returns the set of included and excluded posts."""

        entry_links = {(entry.title, entry.link) for entry in entries}
        included = []
        excluded = []
        for post in posts:
            if (post.title, post.url) in entry_links:
                included.append(post)
            else:
                excluded.append(post)

        return included, excluded

    # @given(st.integers(min_value=0, max_value=N_MAX * 10))
    # FIXME: Hypothesis' shrinking fails because of random dates on posts
    # generated by faker, not hypothesis
    # FIXME: We could also use py.test to parametrize these tests
    def verify_feed_generation(self, n):
        # Given
        self.clear_db()
        self.login()
        self.setup_test_user()
        posts = create_posts(n)

        # When
        response = self.client.get('/atom.xml', data={'token': self.hacker.token})

        # Then
        self.assertEqual(n, Post.objects.count())
        self.assertEqual(n, len(posts))
        self.assertEqual(200, response.status_code)
        feed = self.parse_feed(response.content)
        entries = feed.entries
        self.assertEqual(min(n, N_MAX), len(entries))
        if n < 1:
            return

        self.assertGreaterEqual(entries[0].updated_parsed,
                                entries[-1].updated_parsed)
        included, excluded = self.get_included_excluded_posts(posts, entries)
        self.assertEqual(len(included), len(entries))
        if not excluded:
            return

        max_excluded_date = max(excluded, key=lambda x: x.date_posted_or_crawled).date_posted_or_crawled
        min_included_date = min(included, key=lambda x: x.date_posted_or_crawled).date_posted_or_crawled
        self.assertGreaterEqual(min_included_date, max_excluded_date)
